package goscala

import (
	"fmt"
)


type Either[L, R any] interface {
	fmt.Stringer

	Contains(R, EqualFunc[R]) bool
	Equals(Either[L, R], EqualFunc[L], EqualFunc[R]) bool

	IsLeft() bool
	IsRight() bool
	Left() L
	Right() R
	Get() R
	Option() Option[R]
	Exists(p Predict[R]) bool
	FilterOrElse(p Predict[R], z L) Either[L, R]
	Forall(p Predict[R]) bool
	Foreach(f func(R))
	GetOrElse(z R) R
	OrElse(z Either[L, R]) Either[L, R]
	Swap() Either[R, L]
}

type either[L, R any] struct {
	right bool
	lv L
	rv R
}

func (e *either[L, R]) String() string {
	if e.right {
		return fmt.Sprintf(`Right(%v)`, e.rv)
	}
	return fmt.Sprintf(`Left(%v)`, e.lv)
}

func (e *either[L, R]) Contains(z R, fn EqualFunc[R]) bool {
	if e.IsRight() {
		return fn(e.Right(), z)
	}
	return false
}

func (e *either[L, R]) Equals(that Either[L, R], lf EqualFunc[L], rf EqualFunc[R]) bool {
	if e.IsRight() == that.IsRight() {
		if e.IsRight() {
			return rf(e.Right(), that.Right())
		}
		return lf(e.Left(), that.Left())
	}

	return false
}

func (e *either[L, R]) IsLeft() bool {
	return !e.right
}

func (e *either[L, R]) Left() L {
	if e.IsLeft() {
		return e.lv
	}
	panic(fmt.Sprintf(`can not get left value from %v`, e))
}

func (e *either[L, R]) IsRight() bool {
	return e.right
}

func (e *either[L, R]) Right() R {
	if e.IsRight() {
		return e.rv
	}
	panic(fmt.Sprintf(`can not get right value from %v`, e))
}

func (e *either[L, R]) Get() R {
	return e.Right()
}

func (e *either[L, R]) Option() Option[R] {
	if e.IsRight() {
		return Some[R](e.rv)
	}
	return None[R]()
}

func (e *either[L, R]) Exists(p Predict[R]) bool {
	if e.right {
		return p(e.rv)
	}
	return false
}

func (e *either[L, R]) FilterOrElse(p Predict[R], z L) Either[L, R] {
	if !e.right || p(e.rv) {
		return e
	}

	return Left[L, R](z)
}

func (e *either[L, R]) Forall(p Predict[R]) bool {
	if e.right {
		return p(e.rv)
	}
	return true
}

func (e *either[L, R]) Foreach(f func(R)) {
	if e.right {
		f(e.rv)
	}
}

func (e *either[L, R]) GetOrElse(z R) R {
	if e.right {
		return e.rv
	}

	return z
}

func (e *either[L, R]) OrElse(z Either[L, R]) Either[L, R] {
	if !e.right {
		return z
	}
	return e
}

func (e *either[L, R]) Swap() Either[R, L] {
	if e.right {
		return Left[R, L](e.rv)
	}

	return Right[R, L](e.lv)
}

//func (e *either[L, R]) Try() *Try[R] {
//	if e.right {
//		return Success[R](e.rv)
//	}
//
//	return Failure[R](fmt.Errorf(`%v`, e.lv))
//}
